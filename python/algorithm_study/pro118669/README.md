## 프로그래머스 등산코스 정하기

### 문제 풀이

- 모든 노드에 대한 Intense 정보를 갖는 배열을 선언하고 INF로 초기화한다.
- 게이트에 해당하는 노드의 Intense를 0으로 변경하고, 해당 노드들은 우선순위 큐에 넣고 탐색을 시작한다.
  - 우선순위 큐에는 (현재까지의 최대 강도, 현재 노드) 순으로 넣는다.
  - 작은 가중치에 해당하는 노드를 먼저 탐색해야, 뒤에 쓸데없이 탐색되는 노드가 줄어든다.
- 큐에서 나온 노드 정보가 다음에 해당할 경우 pass한다.
  - 큐에서 나온 노드가 정상(summit)이라면 다른 노드로 더 이동할 필요 없으므로 pass
  - 큐에서 나온 노드에서, Intense 정보 > dp[현재 노드] 일 경우 pass한다.
    - Intense 정보 = dp[현재 노드]인 경우는 탐색해야 한다. 이 경로를 통해 정상에 가는 추가 경로를 탐색해야하기 때문이다.
- 큐에서 나온 노드(부모)에 연결된 노드들을 탐색한다.
  - 큐에서 나온 노드까지의 거리와 부모 노드가 가진 intense를 비교한다.
    - dp[큐에서 나온 노드] >= max(dist, 부모의 intense)일 경우 pass한다.
    - 이번에는 같은 경우도 pass하는 이유는, 해당 노드는 이미 다른 루트에 의해 갱신된 노드이기 때문이다. 굳이 두 번 탐색할 필요 없다.
    - 즉, 앞의 경우 들어갈 당시에는 `dp < max(dist, intense)`를 만족하였으며 해당 노드 탐색을 통해 다른 summit으로 갈 수 있는 경로가 나올 수 있기 때문이다.
  - 위 조건을 만족한 경우 큐에 넣고 반복한다.
- 위의 반복이 끝난 상태에서는 dp에 모든 노드에 대한 최소 강도가 작성되어 있을 것이다. 결국 summit들에는 도달하기 위한 가장 최소한의 강도가 작성되어 있을 것이다.